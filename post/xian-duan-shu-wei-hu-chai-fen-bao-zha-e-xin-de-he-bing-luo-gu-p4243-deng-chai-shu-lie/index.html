<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>【线段树维护差分+爆炸恶心的合并】洛谷P4243 等差数列 | 名神龙二の存档点</title>
<link rel="shortcut icon" href="https://clf02z.coding-pages.com/favicon.ico?v=1583813701902">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.css" rel="stylesheet">
<link rel="stylesheet" href="https://clf02z.coding-pages.com/styles/main.css">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/go.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
        integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
        integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
        crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
        integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
        crossorigin="anonymous"></script>

<!-- DEMO JS -->
<script src="media/scripts/index.js"></script>



    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            名神龙二の存档点
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
    </div>
</nav>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    【线段树维护差分+爆炸恶心的合并】洛谷P4243 等差数列
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-03-06 ·
                    </time>
                    
                </div>
                <div class="post-content">
                    <p><a href="https://www.luogu.org/problemnew/show/P4243">题面</a></p>
<p>首先感谢<a href="https://www.cnblogs.com/cjyyb/p/8557066.html">这篇题解</a>，是思路来源</p>
<hr>
<p>看到等差数列，就会想到差分，又有区间加，很容易想到线段树维护差分。再注意点细节，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>操作完美解决<br>
然后就是爆炸恶心的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>操作，之前看一堆题解的解释都不怎么明白，就自己脑补+看上面那篇题解乱搞出了个相对合理点的解释……<br>
用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">0/1/2/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span></span></span></span>分别表示一个差分区间统计答案时，是否跨越原区间左右端点。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">s[0/1/2/3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span><span class="mclose">]</span></span></span></span>分别表示每个状态的最少可以划分出来的等差数列个数。<br>
合并方式如下：</p>
<pre><code class="language-cpp">/*定义差分b[i]=a[i+1]-a[i]
假设要查询区间[S,T]，对应到差分数组实际查询的是区间[S,T-1]
所以一个节点如果在差分数组上维护的区间是[a,b],在原数组上维护的实际上是区间[a,b+1]*/

//s[0]表示原数组中区间为(S,T)的答案
//s[1]表示原数组中区间为(S,T]的答案
//s[2]表示原数组中区间为[S,T)的答案
//s[3]表示原数组中区间为[S,T]的答案

s[0]= min(s[1]+ s[2]- ( vr==Y.vl), min(s[0]+ s[2], s[1]+s[0] ) );

s[1]= min(s[1]+ Y.s[3]- ( vr==Y.vl), min(s[1]+ s[1], s[0]+s[3] ) );

s[2]= min(s[3]+ s[2]- ( vr==Y.vl), min(s[2]+ s[2], s[3]+s[0] ) );

s[3]= min(s[3]+ s[3]- ( vr==Y.vl), min(s[3]+ s[1], s[2]+s[3] ) );

</code></pre>
<p>输出时直接输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">s[3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span></span></span></span>就OK了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">p.s.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n==1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时不用建树,否则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">RE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></p>
<p>代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define N 100005
using namespace std;

int a[N],n;

#define bas int l,int r,int o
#define lson l,mid,o&lt;&lt;1
#define rson mid+1,r,o&lt;&lt;1|1

struct node{
    int s[4];
	long long vl,vr;
    node operator +(const node &amp;Y)const{
        node Z;
        Z.vl=vl,Z.vr=Y.vr; 
        Z.s[0]= min(s[1]+ Y.s[2]- ( vr==Y.vl), min(s[0]+ Y.s[2], s[1]+Y.s[0] ) );
        Z.s[1]= min(s[1]+ Y.s[3]- ( vr==Y.vl), min(s[1]+ Y.s[1], s[0]+Y.s[3] ) );
        Z.s[2]= min(s[3]+ Y.s[2]- ( vr==Y.vl), min(s[2]+ Y.s[2], s[3]+Y.s[0] ) );
        Z.s[3]= min(s[3]+ Y.s[3]- ( vr==Y.vl), min(s[3]+ Y.s[1], s[2]+Y.s[3] ) );
        return Z; 
    }
};
struct qwq{
    long long tag[N&lt;&lt;2];
    node t[N&lt;&lt;2]; 
    void pushdown(int o){
        t[o&lt;&lt;1].vl+= tag[o], t[o&lt;&lt;1].vr+= tag[o];
        t[o&lt;&lt;1|1].vl+= tag[o], t[o&lt;&lt;1|1].vr+= tag[o];
        tag[o&lt;&lt;1]+= tag[o], tag[o&lt;&lt;1|1]+= tag[o]; 
        tag[o]=0;
    }
    void build(bas){
    	tag[o]=0;
        if(l==r){
            t[o].vl= t[o].vr= a[l];
            t[o].s[1]= t[o].s[2]= t[o].s[3]= 1, t[o].s[0]=0;//两个数时和一个数时等差数列数量都是1
            return;
        }
        int mid=(l+r)&gt;&gt;1;
        build(lson),build(rson);
        t[o]= t[o&lt;&lt;1]+ t[o&lt;&lt;1|1];
    }
    void update(bas,int L,int R,long long x){
        if(L&lt;=l &amp;&amp; r&lt;=R){
            t[o].vl+= x, t[o].vr+= x;
            tag[o]+= x;
            return;
        }
        if(tag[o]) pushdown(o);
        int mid= (l+r)&gt;&gt;1;
        if(L&lt;= mid) update(lson,L,R,x);
        if(R&gt; mid) update(rson,L,R,x);
        t[o]= t[o&lt;&lt;1]+ t[o&lt;&lt;1|1];        
    }
    node query(bas,int L,int R){ 
        if(L&lt;= l &amp;&amp; r&lt;= R) return t[o];
        if(tag[o]) pushdown(o);
        int mid= (l+r)&gt;&gt;1;
        if(R&lt;=mid) return query(lson,L,R);
		else{
			if(L&gt;mid) return query(rson,L,R);
			else return query(lson,L,R)+query(rson,L,R);
		} 	
    }	
}T;

int main(){
    int q,s,t,c,d,ans,i;
    char op;
    scanf(&quot;%d&quot;,&amp;n);
    for(i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);
    for(i=1;i&lt;n;++i) a[i]=a[i+1]-a[i];
    if(n!=1) T.build(1,n-1,1);
    scanf(&quot;%d&quot;,&amp;q);
    while(q--){
        scanf(&quot;\n%c&quot;,&amp;op);
        if(op=='A'){
            scanf(&quot;%d%d%d%d&quot;,&amp;s,&amp;t,&amp;c,&amp;d);
            if(s!=1) T.update(1,n-1,1,s-1,s-1,c);
            if(t!=n) T.update(1,n-1,1,t,t,1ll*d*s-1ll*d*t-c); 
            if(s!=t) T.update(1,n-1,1,s,t-1,d);
        } else{
            scanf(&quot;%d%d&quot;,&amp;s,&amp;t);
            if(t- s+ 1==1) ans=1; 
            else{
                node res=T.query(1,n-1,1,s,t-1);
                ans=min((t-s+2)/2,res.s[3]);
            }
            printf(&quot;%d\n&quot;,ans); 
        }
    }
}
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://clf02z.coding-pages.com/post/xue-xi-bi-ji-hou-zhui-shu-zu/" class="post-title gt-a-link">
                    【学习笔记】后缀数组
                </a>
            </div>
        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">删库跑路之后留下来的（自认为）有点用的文章。</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a href="https://clf02z.coding-pages.com/atom.xml" target="_blank">RSS</a>
</div>

<script>
    hljs.initHighlightingOnLoad()
</script>


    </div>
</div>
</body>
</html>
