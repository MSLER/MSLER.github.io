
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>【树形dp/启发式合并】AGC007E | 名神龙二の存档点</title>
<meta name="description" content="删库跑路之后留下来的（自认为）有点用的文章。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://msler.github.io/favicon.ico?v=1587288005984">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://msler.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://msler.github.io">
        <img class="avatar" src="https://msler.github.io/images/avatar.png?v=1587288005984" alt="" width="32px" height="32px">
      </a>
      <a href="https://msler.github.io">
        <h1 class="site-title">名神龙二の存档点</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">【树形dp/启发式合并】AGC007E</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-03-06</span>
            
          </div>
          <div class="post-content">
            <p>考场上把这题丢去翻译了一下，然后自闭了……</p>
<p>考完以后：嗯？有每条边最多经过两次的限制吗？？<s>日文题面写得很清楚的样子</s> <s>然而我看的英文题面</s></p>
<hr>
<p>按照套路先二分一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span></p>
<p>每条边最多只能经过两次，意味着必须遍历叶节点时，必须先遍历完同一棵子树的叶节点，考虑从下往上做</p>
<p>然后就是一个快乐的树形DP：设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[x][a][b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span>表示遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的子树时，由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>到遍历到的第一个叶节点的距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，由最后一个被遍历到的叶节点到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></p>
<p>有$$f[x][a][b]=(f[lson][a][l1]&amp;f[rson][l2][b]&amp;[l1+val_{lson}+l2+val_{rson}\leq ans])|(f[lson][l3][b]&amp;f[rson][a][l4]&amp;[l3+val_{lson}+l4+val_{rson}\leq ans])$$</p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>表示边权</p>
<p>注意到对于每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，只用保留<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>最小的状态，对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>也是同理</p>
<p>所以状态数只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个</p>
<p>用vector存状态，转移的时候启发式合并</p>
<p>我也不是很明白这么转移复杂度为什么是对的……</p>
<pre><code class="language-cpp">    #include &lt;bits/stdc++.h&gt;
    #define N 231080
    #define ll long long
    #define For(i,x,y) for(int i=(x);i&lt;=(y);++i)
    #define Rof(i,x,y) for(int i=(x);i&gt;=(y);--i)
    #define Edge(x) for(int i=head[x];i;i=e[i].nxt)
    #define pii pair&lt;ll,ll&gt;
    #define mp make_pair
    #define fr first
    #define sd second
    #define mcpy(x,y) memcpy(x,y,sizeof(x))
    #define mset(x,y) memset(x,y,sizeof(x))
    using namespace std;
    int n,cnt[N];
    ll mn[N];
    vector&lt;pii&gt; a[N];
    vector&lt;int&gt; g[N];
    bool cmp1(const pii &amp;x,const pii &amp;y){ return x.fr&lt;y.fr; }
    bool cmp2(const pii &amp;x,const pii &amp;y){ return x.sd&lt;y.sd; }
    struct ed{ int v,w; }ch[N][2];
    void merge(vector&lt;pii&gt; &amp;c,vector&lt;pii&gt; &amp;aa,vector&lt;pii&gt; &amp;bb,ll val){
    	//if(aa.size()&lt;bb.size()) aa.swap(bb);
    	sort(aa.begin(),aa.end(),cmp2);
    	sort(bb.begin(),bb.end(),cmp1);
    	int _a=(int)aa.size(),_b=(int)bb.size();
    	int p=_a-1;
    	mn[0]=aa[0].fr;
    	For(i,1,_a-1) mn[i]=min(mn[i-1],aa[i].fr);
    	For(i,0,_b-1){
    		while(p&gt;=0 &amp;&amp; aa[p].sd+bb[i].fr&gt;val) p--;
    		if(p&gt;=0) c.push_back(mp(mn[p],bb[i].sd));
    	}p=_a-1;
    	sort(aa.begin(),aa.end(),cmp1);
    	sort(bb.begin(),bb.end(),cmp2);
    	mn[0]=aa[0].sd;
    	For(i,1,_a-1) mn[i]=min(mn[i-1],aa[i].sd);
    	For(i,0,_b-1){
    		while(p&gt;=0 &amp;&amp; aa[p].fr+bb[i].sd&gt;val) p--;
    		if(p&gt;=0) c.push_back(mp(bb[i].fr,mn[p]));
    	}
    }
    void dfs(int x,ll val){
    	if(!a[x].empty()) a[x].clear();
    	if(!cnt[x]){ a[x].push_back(mp(0,0));return; }
    	for(auto to:g[x]) dfs(to,val);
    	vector&lt;pii&gt; &amp;ls=a[ch[x][0].v];
    	vector&lt;pii&gt; &amp;rs=a[ch[x][1].v];
    	For(i,0,(int)ls.size()-1)ls[i].fr+=ch[x][0].w,ls[i].sd+=ch[x][0].w;
    	For(i,0,(int)rs.size()-1) rs[i].fr+=ch[x][1].w,rs[i].sd+=ch[x][1].w;
    	if(ls.size()&lt;rs.size()) swap(ls,rs);
    	merge(a[x],ls,rs,val);
    	a[ch[x][0].v].clear();
    	a[ch[x][1].v].clear();
    }
    bool check(ll x){
    	dfs(1,x);
    	if(a[1].size()==0) return 0;
    	return 1;
    }
    int main(){
    	int x,v;ll ans;
    	ll l=0,r=0;
    	scanf(&quot;%d&quot;,&amp;n);
    	For(i,2,n) scanf(&quot;%d%d&quot;,&amp;x,&amp;v),ch[x][cnt[x]++]=(ed){i,v},g[x].push_back(i),r+=v;
    	ans=r;
    	while(l&lt;=r){
    		ll mid=(l+r)&gt;&gt;1;
    		if(check(mid)) r=mid-1,ans=mid;
    		else l=mid+1;
    	}
    	printf(&quot;%lld\n&quot;,ans);
    }
</code></pre>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://msler.github.io/post/zhao-gui-lu-gou-zao-ji-yi-hua-sou-suo-luo-gu-5362-sdoi2019lian-xu-zi-xu-lie/">
              <h3 class="post-title">
                下一篇：【找规律/构造+记忆化搜索】洛谷5362 [SDOI2019]连续子序列
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">删库跑路之后留下来的（自认为）有点用的文章。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://msler.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
